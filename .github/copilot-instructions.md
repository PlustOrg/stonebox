**Implement the `Stonebox` NPM Package**

**Project Goal:**

You are an expert software engineer. Your task is to implement `Stonebox`, a TypeScript NPM package. `Stonebox` allows developers to run Python, TypeScript, and JavaScript code in a sandboxed environment using Node.js `child_process`. The API should be simple, as prototyped. The package should be extensible to other languages in the future.

**Core Features to Implement:**

1.  **Project Setup:** Initialize an NPM package with TypeScript, linting, and testing configurations.
2.  **Core `Stonebox` Class:** Implement the main class with methods for adding files and executing code.
3.  **Interfaces & Error Handling:** Define clear TypeScript interfaces for options, results, and custom error classes.
4.  **File Management:** Handle user-provided files by writing them to a secure temporary directory for execution.
5.  **Sandboxing via `child_process`:**
    *   Use `child_process.spawn` for execution.
    *   Manage `stdin`, `stdout`, `stderr`.
    *   Implement timeout enforcement.
    *   Capture exit codes and signals.
6.  **Language Engines:**
    *   **JavaScriptEngine:** Executes `.js` files with Node.js.
    *   **PythonEngine:** Executes `.py` files with the system's Python interpreter.
    *   **TypeScriptEngine:** Compiles `.ts` files to JavaScript using the `typescript` compiler, then executes the JavaScript with Node.js.
7.  **Resource Management:** Ensure temporary directories are cleaned up after execution.
8.  **Testing:** Basic unit and integration tests for core functionality.

**Step-by-Step Implementation Guide:**

**Phase 1: Project Setup & Basic Structure**

1.  **Initialize NPM Package:**
    *   Run `npm init -y`.
    *   Set `"name": "stonebox"` in `package.json`.
    *   Add `"type": "module"` to `package.json` for ES module support if preferred, or plan for CommonJS output. (Let's proceed with CommonJS for wider Node.js compatibility unless you have a strong reason for ES modules for this library's build output).

2.  **Install Dependencies:**
    *   `npm install typescript @types/node --save-dev`
    *   `npm install rimraf tmp --save` (for temporary directory management and cleanup)
    *   `npm install ts-jest @types/jest jest --save-dev` (for testing)

3.  **TypeScript Configuration:**
    *   Run `npx tsc --init`.
    *   Modify `tsconfig.json`:
        ```json
        {
          "compilerOptions": {
            "target": "ES2020", // Or newer, balance compatibility & features
            "module": "commonjs",
            "outDir": "./dist",
            "rootDir": "./src",
            "strict": true,
            "esModuleInterop": true,
            "skipLibCheck": true,
            "forceConsistentCasingInFileNames": true,
            "declaration": true, // Generate .d.ts files
            "sourceMap": true
          },
          "include": ["src/**/*"],
          "exclude": ["node_modules", "dist", "tests"]
        }
        ```

4.  **Linting (Optional but Recommended):**
    *   `npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-config-prettier eslint-plugin-prettier --save-dev`
    *   Set up `.eslintrc.js` and `.prettierrc.js`.

5.  **`package.json` Scripts:**
    ```json
    "scripts": {
      "build": "rimraf ./dist && tsc",
      "lint": "eslint . --ext .ts",
      "test": "jest",
      "prepublishOnly": "npm run build"
    }
    ```

6.  **Directory Structure:**
    ```
    stonebox/
    ├── src/
    │   ├── index.ts             // Main export point
    │   ├── stonebox.ts          // Stonebox class definition
    │   ├── interfaces.ts        // All public interfaces (options, result)
    │   ├── errors.ts            // Custom error classes
    │   └── engines/             // Language-specific execution logic
    │       ├── types.ts         // LanguageEngine interface
    │       ├── javascriptEngine.ts
    │       ├── pythonEngine.ts
    │       └── typescriptEngine.ts
    ├── tests/
    │   ├── stonebox.spec.ts
    │   └── engines/
    │       └── typescriptEngine.spec.ts // Example
    ├── dist/                    // Output directory (generated by tsc)
    ├── node_modules/
    ├── package.json
    ├── package-lock.json
    ├── tsconfig.json
    └── jest.config.js
    ```

7.  **Jest Configuration (`jest.config.js`):**
    ```javascript
    module.exports = {
      preset: 'ts-jest',
      testEnvironment: 'node',
      roots: ['<rootDir>/tests'],
      testMatch: ['**/*.spec.ts'],
    };
    ```

**Phase 2: Core Interfaces, Errors, and `Stonebox` Class Skeleton**

1.  **`src/interfaces.ts`:**
    *   Define `StoneboxOptions`, `StoneboxExecuteOptions`, `StoneboxExecutionResult` as per the refined API proposal (previous discussion).

2.  **`src/errors.ts`:**
    *   Define `StoneboxError` base class and subclasses: `StoneboxConfigurationError`, `StoneboxTimeoutError`, `StoneboxCompilationError` (with `compilerStdout?`, `compilerStderr?`), `StoneboxMemoryLimitError`, `StoneboxRuntimeError`.

3.  **`src/stonebox.ts` (Skeleton):**
    *   Import necessary interfaces and errors.
    *   Define the `Stonebox` class.
    *   Implement the constructor: `constructor(language: string, options: StoneboxOptions = {})`. Store language and options. Add a basic language support check (e.g., throw `StoneboxConfigurationError` for unsupported languages).
    *   Implement file management:
        *   `private files: Map<string, string> = new Map();`
        *   `public addFile(filePath: string, content: string): void`
        *   `public addFiles(files: Array<{ path: string; content: string }>): void`
        *   `public resetFiles(): void`
    *   Stub out `public async execute(executeOptionsInput?: StoneboxExecuteOptions): Promise<StoneboxExecutionResult>` (throw `NotImplementedError` for now).

4.  **`src/index.ts`:**
    *   Export `Stonebox` class, all interfaces from `interfaces.ts`, and all error classes from `errors.ts`.

**Phase 3: `Stonebox.execute()` Orchestration & Temporary File Management**

1.  **Import Dependencies in `stonebox.ts`:**
    *   `import * as fs from 'fs/promises';`
    *   `import * as path from 'path';`
    *   `import * as os from 'os';`
    *   `import { spawn } from 'child_process';`
    *   `import * as tmp from 'tmp';` (Use `tmp.dirSync()` for synchronous creation or promisify its async version)
    *   `import { rimraf } from 'rimraf';` (For cleaning up non-empty directories; `fs.rm` with `recursive: true` is also an option in newer Node).
    *   `import { AbortController } from 'node-abort-controller';` (Or use built-in if Node version is >=15.4.0, or polyfill if needed for broader compatibility. For now, assume available or use a simple flag for timeout).

2.  **Implement `Stonebox.execute()` core logic:**
    *   Merge instance `this.options` with `executeOptionsInput`. Determine final `timeoutMs`, `memoryLimitMb`, `entrypoint`, `args`, `stdin`, `env`.
    *   Validate `entrypoint` and that files are added.
    *   **Temporary Directory:**
        *   Use `tmp.dir({ unsafeCleanup: true, prefix: 'stonebox-' }, async (err, tempDirPath, cleanupCallback) => { ... });` or manage manually:
            *   Create a unique temporary directory: `const tempDirPath = await fs.mkdtemp(path.join(os.tmpdir(), 'stonebox-'));`
            *   Implement a `finally` block to ensure `rimraf(tempDirPath)` or `await fs.rm(tempDirPath, { recursive: true, force: true });` is called.
    *   **Write Files:** Iterate `this.files` and write each file to its relative path within `tempDirPath`. Create subdirectories as needed (`await fs.mkdir(path.dirname(fullPath), { recursive: true });`).
    *   **Language Engine Selection:**
        *   `const engine = this.getEngineFor(this.language);` (Implement `getEngineFor` later).
    *   **Prepare Command (defer to engine):**
        *   `const preparedCmd = await engine.prepare({ files: this.files, entrypoint, options: mergedOptions, tempPath: tempDirPath });`
        *   If `preparedCmd` is a `StoneboxCompilationError`, throw it.
    *   **Spawn Process:**
        *   `const abortController = new AbortController();`
        *   `const child = spawn(preparedCmd.command, preparedCmd.args, { cwd: preparedCmd.cwd, env: preparedCmd.env, stdio: ['pipe', 'pipe', 'pipe'], signal: abortController.signal });`
    *   **Timeout Handling:**
        *   `const timeoutHandle = setTimeout(() => { abortController.abort(); child.kill('SIGTERM'); /* ... more logic ... */ }, finalTimeoutMs);`
        *   If `child.kill('SIGTERM')` doesn't work after a grace period (e.g. 500ms), consider `child.kill('SIGKILL')`.
    *   **Data Handling & Promise Logic:**
        *   Pipe `mergedOptions.stdin` to `child.stdin`.
        *   Collect `child.stdout` and `child.stderr` data.
        *   Wrap `child.on('error', ...)` and `child.on('exit', ...)` in a `Promise`.
        *   On `error`: if due to `abortController.signal.aborted`, reject with `StoneboxTimeoutError`. Otherwise, reject with `StoneboxRuntimeError`.
        *   On `exit`: clear timeout. Resolve with `StoneboxExecutionResult` (stdout, stderr, exitCode, duration, signal). If `abortController.signal.aborted` and the exit was due to our kill, reject with `StoneboxTimeoutError`.
    *   **Cleanup:** Ensure the `finally` block cleans up the temp directory.

**Phase 4: Language Engine Implementation (`src/engines/`)**

1.  **`src/engines/types.ts`:**
    ```typescript
    import { StoneboxExecuteOptions, StoneboxOptions } from '../interfaces';
    import { StoneboxCompilationError } from '../errors';

    export interface ExecutionTask {
        files: Map<string, string>;
        entrypoint: string;
        options: StoneboxExecuteOptions & Partial<StoneboxOptions>; // Merged options
        tempPath: string;
    }

    export interface PreparedCommand {
        command: string;
        args: string[];
        env: Record<string, string | undefined>;
        cwd: string;
    }

    export interface LanguageEngine {
        prepare(task: ExecutionTask): Promise<PreparedCommand | StoneboxCompilationError>;
    }
    ```

2.  **`src/engines/javascriptEngine.ts`:**
    *   Implement `JavaScriptEngine implements LanguageEngine`.
    *   `prepare(task: ExecutionTask)`:
        *   `command`: `process.execPath` (current Node.js executable).
        *   `args`: `[task.entrypoint, ...(task.options.args || [])]`. If `task.options.memoryLimitMb` is set, prepend Node's `--max-old-space-size=VALUE` to args.
        *   `env`: `process.env` merged with `task.options.env`.
        *   `cwd`: `task.tempPath`.
        *   Return `PreparedCommand`.

3.  **`src/engines/pythonEngine.ts`:**
    *   Implement `PythonEngine implements LanguageEngine`.
    *   `prepare(task: ExecutionTask)`:
        *   `command`: `"python3"` (or `"python"`). Consider making this configurable via `StoneboxOptions.languageOptions`.
        *   `args`: `[task.entrypoint, ...(task.options.args || [])]`.
        *   `env`, `cwd` similar to `JavaScriptEngine`.
        *   Return `PreparedCommand`.

4.  **`src/engines/typescriptEngine.ts`:**
    *   Add `typescript` to `dependencies` or `peerDependencies` in `package.json` (if not already a dev dep that can be accessed via `npx`). For simplicity, let's make `typescript` a direct dependency of `stonebox`.
        `npm install typescript --save` (this is for the *engine* to use, not just for stonebox's own dev).
    *   Import `spawn` for the compilation step.
    *   Implement `TypeScriptEngine implements LanguageEngine`.
    *   `prepare(task: ExecutionTask)`:
        1.  **Compilation Step:**
            *   Determine `tsc` path (e.g., `path.join('node_modules', '.bin', 'tsc')` or rely on `npx tsc`).
            *   Create a default `tsconfig.json` in `task.tempPath` if one isn't provided via `task.options.languageOptions.compilerConfigPath` or embedded options.
                Default `tsconfig.json` could be: `{ "compilerOptions": { "target": "es2020", "module": "commonjs", "outDir": "./compiled_ts" } }`. Ensure `outDir` is within `task.tempPath`.
            *   Spawn `tsc` process: `spawn(tscPath, ['-p', 'tsconfig.json'], { cwd: task.tempPath, stdio: 'pipe' })`.
            *   Capture `tsc`'s stdout/stderr. If `exitCode !== 0`, return `new StoneboxCompilationError("TypeScript compilation failed.", { stdout: tscStdout, stderr: tscStderr })`.
        2.  **Prepare JS Execution:**
            *   `command`: `process.execPath`.
            *   `args`: Point to the compiled JS entrypoint (e.g., `path.join(task.tempPath, 'compiled_ts', task.entrypoint.replace('.ts', '.js'))`). Add memory limits and user args.
            *   `env`, `cwd` similar to `JavaScriptEngine`.
            *   Return `PreparedCommand`.

5.  **Update `Stonebox.getEngineFor(language: string)` in `stonebox.ts`:**
    *   Return new instances of `JavaScriptEngine`, `PythonEngine`, `TypeScriptEngine` based on `language` string. Throw `StoneboxConfigurationError` for unsupported languages.

**Phase 5: Testing (`tests/`)**

1.  **`tests/stonebox.spec.ts`:**
    *   **JavaScript:**
        *   Test basic "hello world".
        *   Test `stdin`, `args`, `env`.
        *   Test timeout (`StoneboxTimeoutError`).
        *   Test script error (non-zero `exitCode`).
    *   **Python:**
        *   Similar tests as JavaScript.
    *   **TypeScript:**
        *   Test basic "hello world" (successful compilation & execution).
        *   Test `stdin`, `args`, `env` with TypeScript.
        *   Test compilation failure (`StoneboxCompilationError`).
        *   Test execution timeout after successful compilation.
    *   **General `Stonebox` Tests:**
        *   `addFile`, `addFiles`, `resetFiles`.
        *   `StoneboxConfigurationError` for no files, invalid entrypoint, unsupported language.
        *   Ensure temp directory is cleaned up (this is harder to test directly without inspecting the OS, but check for no errors during cleanup).

    **Example Test Script (JavaScript Hello World):**
    ```typescript
    // tests/stonebox.spec.ts
    import { Stonebox, StoneboxTimeoutError } from '../src'; // Adjust path as needed

    describe('Stonebox JavaScript Execution', () => {
        it('should execute a simple JavaScript "hello world"', async () => {
            const sandbox = new Stonebox('javascript');
            sandbox.addFile('main.js', 'console.log("Hello JS World");');
            const result = await sandbox.execute();
            expect(result.stdout.trim()).toBe('Hello JS World');
            expect(result.stderr).toBe('');
            expect(result.exitCode).toBe(0);
        });

        it('should handle stdin for JavaScript', async () => {
            const sandbox = new Stonebox('javascript');
            sandbox.addFile('main.js', 'process.stdin.on("data", data => console.log(data.toString().toUpperCase()));');
            const result = await sandbox.execute({ stdin: 'test input' });
            expect(result.stdout.trim()).toBe('TEST INPUT');
        });

        // ... more tests for args, env, errors, timeout ...

        it('should throw StoneboxTimeoutError for a long-running JS script', async () => {
            const sandbox = new Stonebox('javascript', { timeoutMs: 100 });
            sandbox.addFile('main.js', 'setTimeout(() => console.log("done"), 500);');
            await expect(sandbox.execute()).rejects.toThrow(StoneboxTimeoutError);
        });
    });
    // Add describe blocks for Python, TypeScript, and General Stonebox functionality
    ```

**Phase 6: Build and Polish**

1.  Run `npm run build`. Check `dist/` for compiled JS and `.d.ts` files.
2.  Update `package.json`:
    *   `"main": "dist/index.js"`
    *   `"types": "dist/index.d.ts"`
    *   `"files": ["dist"]`
3.  Write a basic `README.md` with installation and usage examples.

**Important Considerations for the AI:**

*   **Security:** Emphasize that `child_process` sandboxing has limitations. The code does not prevent the script from trying to access the file system outside its temp directory or making network calls. This is a known limitation for this phase.
*   **Cross-Platform:** `python3` vs `python` can be an issue. The `tsc` path might also need care. For now, assume standard paths or simple configurations.
*   **Error Propagation:** Ensure errors from `child_process` and internal logic are correctly wrapped in `StoneboxError` subclasses.
*   **Resource Limits:** Memory limiting via `--max-old-space-size` is specific to Node.js. Python memory limiting is OS-dependent and harder to implement robustly via `child_process` without OS-specific tools or wrappers (leave this for future improvement or as a known limitation).
*   **Dependencies for Execution:** The user's system must have Node.js installed (for JS/TS execution) and Python installed (for Python execution). `typescript` will be bundled as a dependency by Stonebox for its TS engine.

**Final Output Expectation:**

A fully implemented `stonebox` NPM package directory structure as described, with all TypeScript source files, tests, and configuration files. The package should be buildable and tests should pass.

---

This detailed prompt should give the AI coding agent a solid roadmap to implement `Stonebox`. Good luck!